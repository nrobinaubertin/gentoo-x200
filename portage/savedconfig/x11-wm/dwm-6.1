/* See LICENSE file for copyright and license details. */

// Needed for media keys
#include "X11/XF86keysym.h"

/* appearance */
static const char *fonts[] = { "DejaVuSansMono:size=10" };
static const char dmenufont[]       = "DejaVuSansMono:size=10";
static const char normbordercolor[] = "#928374";
static const char normbgcolor[]     = "#282828";
static const char normfgcolor[]     = "#ebdbb2";
static const char selbordercolor[]  = "#928374";
static const char selbgcolor[]      = "#282828";
static const char selfgcolor[]      = "#ebdbb2";
static const unsigned int borderpx  = 0;        /* border pixel of windows */
static const unsigned int snap      = 32;       /* snap pixel */
static const int showbar            = 0;        /* 0 means no bar */
static const int topbar             = 1;        /* 0 means bottom bar */

/* tagging */
// static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
static const char *tags[] = { "DWM" };

// not used for now
static const Rule rules[] = {
	/* class      instance    title       tags mask     isfloating   monitor */
    { NULL,       NULL,       NULL,       0,            False,       -1 },
};

/* layout(s) */
// not used for now
static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
static const int nmaster     = 1;    /* number of clients in master area */
static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */

static const Layout layouts[] = {
	/* symbol     arrange function */
	{ "monocle",      monocle },
	// { "tile",      tile },    /* first entry is default */
	// { "floating",      NULL },    /* no layout function means floating behavior */
};

static void togglesound(const Arg *arg);
static void alternatescreen(const Arg *arg);
static void changeredshift(const Arg *arg);
static void zoomswap(const Arg *arg);

/* key definitions */
#define MODKEY Mod1Mask
#define WINKEY Mod4Mask
#define TAGKEYS(KEY,TAG) \
	{ WINKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
	{ WINKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
	{ WINKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
	{ WINKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },

/* helper for spawning shell commands in the pre dwm-5.0 fashion */
#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }

/* commands */
static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
static const char *term[]  = { "st", NULL };
static const char *slock[]  = { "slock", NULL };
static const char *web[] = { "firefox", NULL };
static const char *vold[] = { "amixer", "-q", "set", "Master", "5%-", "unmute", NULL };
static const char *volu[] = { "amixer", "-q", "set", "Master", "5%+", "unmute", NULL };
static const char *bklu[] = { "xbacklight", "-steps", "1", "-time", "0", "-inc", "5", NULL };
static const char *bkld[] = { "xbacklight", "-steps", "1", "-time", "0", "-dec", "5", NULL };


/*
 * Rules for the keyboard shortcuts:
 * - use the WINKEY for the shortcuts (so that we have no conflicts with cli apps)
 * - use the ShifMask to avoid pressing the shortcut by accident
 */
static Key keys[] = {
	/* modifier                     key                             function            argument */
	{ WINKEY,                       XK_p,                           spawn,              {.v = dmenucmd } },
	{ WINKEY,                       XK_l,                           spawn,              {.v = slock } },
	{ WINKEY,                       XK_w,                           spawn,              {.v = web } },
	{ WINKEY,                       XK_t,                           spawn,              {.v = term } },
	{ WINKEY,                       XK_j,                           focusstack,         {.i = +1 } },
	{ WINKEY,                       XK_k,                           focusstack,         {.i = -1 } },
	{ WINKEY,                       XK_Tab,                         zoomswap,           {0} },
	{ WINKEY,                       XK_q,                           togglebar,          {0} },
	{ WINKEY,	                    XK_s,                           alternatescreen,    {0} },
	{ WINKEY,	                    XK_r,                           changeredshift,     {.i = +1 } },
	{ WINKEY,	                    XK_b,                           spawn,              {.v = bklu } },
	{ WINKEY|ShiftMask,	            XK_r,                           changeredshift,     {.i = -1 } },
	{ WINKEY|ShiftMask,	            XK_b,                           spawn,              {.v = bkld } },
	{ WINKEY|ShiftMask,             XK_q,                           quit,               {0} },
	{ WINKEY|ShiftMask,             XK_c,                           killclient,         {0} },

    // thinkpad media keys (can be found with `xmodmap -pke`)
	{ 0,	                        XF86XK_MonBrightnessDown,       spawn,              {.v = bkld } },
	{ 0,	                        XF86XK_MonBrightnessUp,         spawn,              {.v = bklu } },
	{ 0,	                        XF86XK_AudioMute,               togglesound,        {0} },
	{ 0,	                        XF86XK_AudioLowerVolume,        spawn,              {.v = vold } },
	{ 0,	                        XF86XK_AudioRaiseVolume,        spawn,              {.v = volu } },

	// { MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
	// { MODKEY,                       XK_b,      togglebar,      {0} },
	// { MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
	// { MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
	// { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
	// { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
	// { MODKEY,                       XK_Tab,    view,           {0} },
	// { MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
	// { MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
	// { MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
	// { MODKEY,                       XK_space,  setlayout,      {0} },
	// { MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
	// { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
	// { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
	// { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
	// { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
	// { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
	// { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
	// TAGKEYS(                        0x26,                      0)
	// TAGKEYS(                        0xe9,                      1)
	// TAGKEYS(                        0x22,                      2)
	// TAGKEYS(                        0x27,                      3)
	// TAGKEYS(                        0x28,                      4)
	// TAGKEYS(                        0x2d,                      5)
	// TAGKEYS(                        0xe8,                      6)
	// TAGKEYS(                        0x5f,                      7)
	// TAGKEYS(                        0xe7,                      8)
};

/* button definitions */
/* click can be ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
// not used. Can I remove this completely ?
static Button buttons[] = {
	/* click                event mask      button          function        argument */
	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
	// { ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
	// { ClkWinTitle,          0,              Button2,        zoom,           {0} },
	// { ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
	// { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
	// { ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
	// { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
	// { ClkTagBar,            0,              Button1,        view,           {0} },
	// { ClkTagBar,            0,              Button3,        toggleview,     {0} },
	// { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
	// { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
};

// funtion that alternates between LVDS1 (laptop screen) and VGA1 (VGA output)
static int screen_id = 0;
void
alternatescreen(const Arg *arg)
{
    if (screen_id % 2 == 0) {
        system("xrandr --output LVDS1 --auto && xrandr --output VGA1 --off");
    } else {
        system("xrandr --output VGA1 --auto && xrandr --output LVDS1 --off");
    }
    screen_id++;
}

// function that controls the redshift status
static int redShift = 0;
void
changeredshift(const Arg *arg)
{
    redShift = ((redShift + arg->i) + 5) % 5;
    switch(redShift) {
        case 4:
            system("redshift -O 2000");
            break;
        case 3:
            system("redshift -O 2600");
            break;
        case 2:
            system("redshift -O 3200");
            break;
        case 1:
            system("redshift -O 3800");
            break;
        case 0:
        default:
            system("redshift -x");
    }
}

// function that controls if the sound is muted
static int isMute = 1;
void
togglesound(const Arg *arg)
{
    if(isMute == 1) {
        system("amixer set Master unmute");
        system("amixer set Speaker unmute");
        system("amixer set Headphone unmute");
        isMute = 0;
    } else {
        system("amixer set Master mute");
        isMute = 1;
    }
}

// zoomswap patch
static Client * findbefore(Client *c);
Client *
findbefore(Client *c) {
	Client *tmp;
	if(c == selmon->clients)
		return NULL;
	for(tmp = selmon->clients; tmp && tmp->next != c; tmp = tmp->next) ;
	return tmp;
}
static Client *prevzoom = NULL;
void
zoomswap(const Arg *arg) {
    Client *c = selmon->sel;
    Client *at = NULL, *cold, *cprevious = NULL;

    if(!selmon->lt[selmon->sellt]->arrange
            || (selmon->sel && selmon->sel->isfloating))
        return;
    if(c == nexttiled(selmon->clients)) {
        at = findbefore(prevzoom);
        if(at)
            cprevious = nexttiled(at->next);
        if(!cprevious || cprevious != prevzoom) {
            prevzoom = NULL;
            if(!c || !(c = nexttiled(c->next)))
                return;
        } else
            c = cprevious;
    }
    cold = nexttiled(selmon->clients);
    if(c != cold && !at)
        at = findbefore(c);
    detach(c);
    attach(c);
    /* swap windows instead of pushing the previous one down */
    if(c != cold && at) {
        prevzoom = cold;
        if(cold && at != cold) {
            detach(cold);
            cold->next = at->next;
            at->next = cold;
        }
    }
    focus(c);
    arrange(c->mon);
}
